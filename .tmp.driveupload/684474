import time
import os
import glob
import shutil
import logging
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import Select
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Credenciales - Primero intenta variables de entorno, luego archivo local
def get_credentials():
    # Prioridad 1: Variables de entorno (para producción)
    user = os.getenv("EVOLTA_USERNAME")
    password = os.getenv("EVOLTA_PASSWORD")
    
    if user and password:
        logger.info("Using credentials from environment variables")
        return user, password
    
    # Prioridad 2: Archivo local (para desarrollo)
    local_paths = [
        os.path.join(os.path.dirname(__file__), "..", "CREDENCIALES.txt"),
        "c:\\Users\\Yrving\\SEMAFORO\\CREDENCIALES.txt",
        "/app/CREDENCIALES.txt"
    ]
    
    for path in local_paths:
        try:
            if os.path.exists(path):
                with open(path, "r") as f:
                    lines = f.readlines()
                    user = lines[0].split(":")[1].strip()
                    password = lines[1].split(":")[1].strip()
                    logger.info(f"Using credentials from file: {path}")
                    return user, password
        except Exception as e:
            logger.warning(f"Could not read credentials from {path}: {e}")
    
    # Fallback
    logger.warning("Using default credentials")
    return "Marketing", "Padovamarketing"

USER_CRED, PASS_CRED = get_credentials()

# Configuración - Directorio de descarga dinámico
DOWNLOAD_DIR = os.getenv("DOWNLOAD_DIR", r"C:\Users\Yrving\Downloads\CARPETA_SEMAFORO")
URL_LOGIN = "https://v4.evolta.pe/Login/Acceso/Index"

# URLs de Reportes
REPORTS = {
    "reporteProspectos": "https://v4.evolta.pe/Reportes/RepHiloProspectos/IndexProspecto",
    "ReporteVenta": "https://v4.evolta.pe/Reportes/RepVenta/Index",
    "Separacion": "https://v4.evolta.pe/Reportes/RepSeparacion/Index",
    "ReporteVisitas": "https://v4.evolta.pe/Reportes/RepVisita/IndexVisita"
}


class EvoltaScraper:
    def __init__(self, download_dir=DOWNLOAD_DIR):
        self.download_dir = download_dir
        self.driver = None
        self._ensure_download_dir()

    def _ensure_download_dir(self):
        if not os.path.exists(self.download_dir):
            os.makedirs(self.download_dir)
        logger.info(f"Download Directory: {os.path.abspath(self.download_dir)}")

    def _get_existing_files(self):
        """Obtiene set de archivos actuales en el directorio"""
        files = glob.glob(os.path.join(self.download_dir, "*"))
        return set(f for f in files if not f.endswith('.crdownload') and not f.endswith('.tmp'))

    def start_driver(self):
        logger.info("Starting Chrome driver...")
        options = webdriver.ChromeOptions()
        
        # Detectar si estamos en Docker/producción
        is_production = os.getenv("ENVIRONMENT") == "production"
        
        if is_production:
            options.add_argument("--headless")
            options.add_argument("--disable-dev-shm-usage")
            chrome_bin = os.getenv("CHROME_BIN", "/usr/bin/google-chrome")
            options.binary_location = chrome_bin
        
        options.add_argument("--disable-gpu")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-popup-blocking")
        options.add_argument("--start-maximized")
        options.add_argument("--window-size=1920,1080")
        options.add_argument("--disable-search-engine-choice-screen")
        
        prefs = {
            "download.default_directory": os.path.abspath(self.download_dir),
            "download.prompt_for_download": False,
            "download.directory_upgrade": True,
            "safebrowsing.enabled": True,
            "profile.default_content_setting_values.automatic_downloads": 1
        }
        options.add_experimental_option("prefs", prefs)
        
        # En producción usar chromedriver instalado, en desarrollo usar webdriver-manager
        if is_production:
            chromedriver_path = os.getenv("CHROMEDRIVER_PATH", "/usr/local/bin/chromedriver")
            service = Service(chromedriver_path)
        else:
            service = Service(ChromeDriverManager().install())
            
        self.driver = webdriver.Chrome(service=service, options=options)
        self.wait = WebDriverWait(self.driver, 20)
        logger.info("Chrome driver started")

    def close(self):
        if self.driver:
            self.driver.quit()
            logger.info("Driver closed")

    def login(self):
        logger.info("Logging in to Evolta...")
        try:
            self.driver.get(URL_LOGIN)
            time.sleep(2)
            
            # Buscar campo usuario
            user_field = None
            for selector in [
                (By.ID, "UserName"),
                (By.NAME, "Usuario"),
                (By.XPATH, "//input[@type='text']")
            ]:
                try:
                    user_field = self.driver.find_element(*selector)
                    break
                except:
                    continue
            
            if not user_field:
                raise Exception("No se encontró campo de usuario")
            
            user_field.clear()
            user_field.send_keys(USER_CRED)
            
            # Password
            pass_field = self.driver.find_element(By.XPATH, "//input[@type='password']")
            pass_field.send_keys(PASS_CRED)
            
            # Submit
            try:
                btn = self.driver.find_element(By.XPATH, "//button[@type='submit'] | //input[@type='submit']")
                btn.click()
            except:
                pass_field.send_keys(Keys.ENTER)
            
            # Esperar cambio de URL
            time.sleep(3)
            self._dismiss_popup()
            
            if "Login" not in self.driver.current_url:
                logger.info(f"Login exitoso: {self.driver.current_url}")
            else:
                raise Exception("Login fallido - URL no cambió")
                
        except Exception as e:
            logger.error(f"Login failed: {e}")
            self._save_screenshot("error_login")
            raise

    def _dismiss_popup(self):
        """Intenta cerrar popups o alertas nativas"""
        try:
            # Alerta nativa
            try:
                alert = self.driver.switch_to.alert
                alert.dismiss()
                logger.info("Alert dismissed")
            except:
                pass
            
            # ESC key
            self.driver.find_element(By.TAG_NAME, 'body').send_keys(Keys.ESCAPE)
            time.sleep(0.5)
        except:
            pass

    def _save_screenshot(self, name):
        try:
            path = os.path.join(self.download_dir, f"{name}_{datetime.now().strftime('%H%M%S')}.png")
            self.driver.save_screenshot(path)
            logger.info(f"Screenshot: {path}")
        except:
            pass

    def _set_dates(self):
        """Configura fechas: inicio = 1ro del mes, fin = HOY"""
        now = datetime.now()
        first_day = now.replace(day=1).strftime("%d/%m/%Y")
        today = now.strftime("%d/%m/%Y")
        
        logger.info(f"Setting dates: {first_day} - {today}")
        
        # Usar JavaScript para setear fechas
        script = f"""
            var inputs = document.querySelectorAll('input');
            var dateInputs = [];
            for (var i = 0; i < inputs.length; i++) {{
                var val = inputs[i].value || '';
                var placeholder = inputs[i].placeholder || '';
                if (val.match(/\\d{{2}}\\/\\d{{2}}\\/\\d{{4}}/) || placeholder.includes('fecha') || inputs[i].type === 'date') {{
                    dateInputs.push(inputs[i]);
                }}
            }}
            if (dateInputs.length >= 2) {{
                dateInputs[0].value = '{first_day}';
                dateInputs[1].value = '{today}';
                dateInputs[0].dispatchEvent(new Event('change', {{ bubbles: true }}));
                dateInputs[1].dispatchEvent(new Event('change', {{ bubbles: true }}));
                return true;
            }}
            return false;
        """
        result = self.driver.execute_script(script)
        time.sleep(1)
        return result

    def _click_search(self):
        """Click en botón Buscar para refrescar tabla"""
        try:
            logger.info("Clicking Search button...")
            btn = None
            # Intento 1: ID
            try: 
                btn = self.driver.find_element(By.ID, "btnBuscar")
            except: pass
            
            # Intento 2: XPath
            if not btn:
                try: 
                    btn = self.driver.find_element(By.XPATH, "//button[contains(text(),'Buscar')]")
                except: pass
            
            if btn:
                self.driver.execute_script("arguments[0].click();", btn)
                time.sleep(4) # Esperar recarga
                
                # Check for alerts post-click
                self._dismiss_popup()
                
                logger.info("Search button clicked")
            else:
                logger.warning("Search button not found")
        except Exception as e:
            logger.warning(f"Error clicking search: {e}")

    def _wait_for_new_file(self, files_before, timeout=180):
        """Espera que aparezca un archivo NUEVO que no existía antes. Timeout 180s."""
        logger.info("Waiting for new file...")
        start_time = time.time()
        
        while (time.time() - start_time) < timeout:
            # Verificar si hay archivos descargándose
            downloading = glob.glob(os.path.join(self.download_dir, "*.crdownload"))
            if downloading:
                logger.info(f"Download in progress: {downloading}")
            
            # Obtener archivos actuales
            current_files = self._get_existing_files()
            
            # Encontrar archivos nuevos
            new_files = current_files - files_before
            
            if new_files:
                # Esperar un momento para asegurar que la descarga termine
                time.sleep(2)
                # Verificar de nuevo
                current_files = self._get_existing_files()
                new_files = current_files - files_before
                
                if new_files:
                    new_file = list(new_files)[0]
                    # Verificar que NO sea .crdownload, .tmp ni .partial
                    if not new_file.endswith('.crdownload') and not new_file.endswith('.tmp') and not new_file.endswith('.partial'):
                         logger.info(f"New file detected: {new_file}")
                         return new_file
            
            time.sleep(1)
            
        logger.warning("Timeout waiting for new file")
        return None

    def _select_all_projects(self, filename):
        """
        Intenta seleccionar 'Todo' en el selector de proyectos.
        SOLO aplica para 'reporteProspectos', ya que otros reportes 
        ya vienen con 'TODOS' por defecto y no tienen el value '--Todo--'.
        """
        if filename != "reporteProspectos":
            logger.info(f"Skipping project selection for {filename} (defaults preserved)")
            return

        try:
            # Buscar el select por ID o nombre común
            select_elem = None
            try:
                select_elem = self.driver.find_element(By.ID, "ddlproyecto")
            except:
                try:
                    select_elem = self.driver.find_element(By.NAME, "ddlproyecto")
                except:
                    # Fallback general: primer select visible
                    try:
                        select_elem = self.driver.find_element(By.TAG_NAME, "select")
                    except: pass
            
            if select_elem:
                select = Select(select_elem)
                # Intentar seleccionar por valor "--Todo--"
                try:
                    select.select_by_value("--Todo--")
                    logger.info("Selected project: --Todo--")
                except Exception as e:
                    logger.warning(f"Could not select '--Todo--': {e}")
                
                # Disparar evento change por si acaso
                self.driver.execute_script("arguments[0].dispatchEvent(new Event('change', { bubbles: true }));", select_elem)
                time.sleep(1)
            else:
                logger.info("No project selector found (might be correct for this page)")

        except Exception as e:
            logger.warning(f"Error selecting all projects: {e}")

    def _export_report(self, url, filename):
        """Exporta un reporte de la URL dada"""
        logger.info(f"=== Exporting: {filename} from {url} ===")
        
        # Guardar lista de archivos ANTES de descargar
        files_before = self._get_existing_files()
        
        # Guardar lista de archivos ANTES de descargar
        files_before = self._get_existing_files()
        
        try:
            # Navegación robusta con reintentos
            navigated = False
            for attempt in range(3):
                try:
                    logger.info(f"Navigating to {url} (Attempt {attempt+1})")
                    self.driver.get(url)
                    time.sleep(3)
                    
                    # Verificar si hubo alerta inesperada
                    self._dismiss_popup()
                    
                    # Detección de Error 500 / Inesperado
                    try:
                        body_text = self.driver.find_element(By.TAG_NAME, "body").text.lower()
                        if "error inesperado" in body_text or "error 500" in body_text or "ha ocurrido un error" in body_text:
                            logger.warning(f"Detected Error Page (500/Inesperado) on attempt {attempt+1}. Retrying...")
                            self.driver.refresh()
                            time.sleep(3)
                            continue 
                    except: pass

                    if url.split('?')[0] in self.driver.current_url:
                        navigated = True
                        break
                except Exception as e:
                    logger.warning(f"Navigation error: {e}")
                    # Si hay alerta, intentar cerrarla
                    self._dismiss_popup()
                    time.sleep(2)
            
            if not navigated:
                raise Exception(f"Failed to navigate to {url} after 3 attempts")

            self._dismiss_popup()
            
            # Zoom out
            self.driver.execute_script("document.body.style.zoom='65%'")
            time.sleep(1)
            
            # 1. SELECCIONAR PROYECTO (Solo para prospectos)
            self._select_all_projects(filename)
            
            # 2. Configurar fechas
            self._set_dates()
            
            # 3. IMPORTANTE: Click Buscar para refrescar datos con las fechas nuevas y proyecto
            self._click_search()
            
            # Scroll al fondo
            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
            time.sleep(1)
            
            # Click en Exportar
            export_clicked = False
            
            # Intentar por ID con espera explícita
            try:
                # Usar wait normal para el botón de exportar, es crítico
                btn = self.wait.until(EC.element_to_be_clickable((By.ID, "btnExportar")))
                self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", btn)
                time.sleep(0.5)
                self.driver.execute_script("arguments[0].click();", btn)
                export_clicked = True
                logger.info("Clicked btnExportar by ID")
            except:
                pass
            
            # Intentar por texto
            if not export_clicked:
                for xpath in [
                    "//button[contains(text(),'Exportar')]",
                    "//button[contains(text(),'EXPORTAR')]",
                    "//input[@value='Exportar']",
                    "//a[contains(text(),'Exportar')]"
                ]:
                    try:
                        btn = self.driver.find_element(By.XPATH, xpath)
                        self.driver.execute_script("arguments[0].click();", btn)
                        export_clicked = True
                        logger.info(f"Clicked export via: {xpath}")
                        break
                    except:
                        continue
            
            if not export_clicked:
                self._save_screenshot(f"error_export_{filename}")
                raise Exception(f"No se pudo clickear Exportar en {url}")
            
            # --- NUEVO: Verificar si salió alerta después de exportar (ej: "No hay registros") ---
            try:
                time.sleep(1) # Esperar a que la alerta aparezca
                alert = self.driver.switch_to.alert
                alert_text = alert.text
                logger.warning(f"Alert detected after export click: {alert_text}")
                alert.accept()
                # Si dice "no existen", "sin información", etc., asumimos que no hay descarga
                if "no" in alert_text.lower() or "sin" in alert_text.lower() or "vaci" in alert_text.lower():
                     logger.warning(f"Aborting download wait due to alert: {alert_text}")
                     return None
            except:
                pass
            # -------------------------------------------------------------------------------------

            # Esperar que aparezca archivo NUEVO
            new_file = self._wait_for_new_file(files_before)
            
            if new_file:
                # Renombrar al nombre deseado
                ext = os.path.splitext(new_file)[1]
                target = os.path.join(self.download_dir, f"{filename}{ext}")
                
                # Si el archivo nuevo YA tiene el nombre correcto, no hacer nada
                if os.path.abspath(new_file) == os.path.abspath(target):
                    logger.info(f"File already has correct name: {target}")
                    return target
                
                # Si ya existe el target, eliminarlo primero
                if os.path.exists(target):
                    try:
                        os.remove(target)
                        logger.info(f"Removed existing: {target}")
                    except Exception as e:
                        logger.warning(f"Could not remove {target}: {e}")
                        # Usar nombre alternativo
                        target = os.path.join(self.download_dir, f"{filename}_{datetime.now().strftime('%H%M%S')}{ext}")
                
                # Esperar un momento para asegurar que el archivo no está en uso
                time.sleep(1)
                
                # Renombrar
                try:
                    shutil.move(new_file, target)
                    logger.info(f"Saved as: {target}")
                    return target
                except Exception as e:
                    logger.warning(f"Could not move file: {e}")
                    # El archivo descargado sigue existiendo con su nombre original
                    logger.info(f"Keeping original: {new_file}")
                    return new_file
            else:
                logger.error(f"Download failed for {filename}")
                self._save_screenshot(f"error_download_{filename}")
                return None
                
        except Exception as e:
            logger.error(f"Export error for {filename}: {e}")
            self._save_screenshot(f"error_{filename}")
            return None

    def run_sync(self):
        """Ejecuta la sincronización completa"""
        # Configurar log a archivo para que el usuario pueda verlo
        log_file = os.path.join(self.download_dir, "sync_log.txt")
        file_handler = logging.FileHandler(log_file, mode='w', encoding='utf-8')
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        logger.info("========== STARTING SYNC ==========")
        downloaded = []
        
        try:
            self.start_driver()
            self.login()
            
            for filename, url in REPORTS.items():
                logger.info(f"\n--- Processing: {filename} ---")
                result = self._export_report(url, filename)
                if result:
                    downloaded.append(result)
                    logger.info(f"SUCCESS: {filename}")
                else:
                    logger.error(f"FAILED: {filename}")
                time.sleep(3)  # Pausa entre descargas
            
            logger.info(f"\n========== SYNC COMPLETE ==========")
            logger.info(f"Downloaded {len(downloaded)}/{len(REPORTS)} files:")
            for f in downloaded:
                logger.info(f"  - {f}")
            
            if len(downloaded) != len(REPORTS):
                 logger.warning(f"WARNING: Only {len(downloaded)} of {len(REPORTS)} files downloaded.")
            
            return downloaded
            
        except Exception as e:
            logger.error(f"Sync failed: {e}")
            raise
        finally:
            self.close()
            logger.removeHandler(file_handler)
            file_handler.close()


if __name__ == "__main__":
    scraper = EvoltaScraper()
    scraper.run_sync()
